/*
* Copyright (C) 2014 MediaTek Inc.
* Modification based on code covered by the mentioned copyright
* and/or permission notice(s).
*/
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.gome.launcher;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.PointF;
import android.graphics.Rect;
import android.os.Build;
import android.os.Bundle;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.ActionMode;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.AnimationUtils;
import android.view.animation.Interpolator;
import android.view.animation.LinearInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.gome.launcher.CellLayout.CellInfo;
import com.gome.launcher.FolderInfo.FolderListener;
import com.gome.launcher.UninstallDropTarget.UninstallSource;
import com.gome.launcher.Workspace.ItemOperator;
import com.gome.launcher.accessibility.LauncherAccessibilityDelegate.AccessibilityDragSource;
import com.gome.launcher.config.FeatureFlags;
import com.gome.launcher.move.MoveViewsRestContainer;
import com.gome.launcher.util.DLog;
import com.gome.launcher.util.Thunk;
import com.gome.launcher.util.UiThreadCircularReveal;
import com.mediatek.launcher3.LauncherLog;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource, View.OnClickListener,
        View.OnLongClickListener, DropTarget, FolderListener, TextView.OnEditorActionListener,
        View.OnFocusChangeListener, DragController.DragListener, UninstallSource, AccessibilityDragSource,
        Stats.LaunchSourceProvider, MoveDropTarget.MoveSource, AppSearchWindow.FolderAppListener {

    private static final String TAG = "Launcher.Folder";

    /**
     * We avoid measuring {@link #mContentWrapper} with a 0 width or height, as this
     * results in CellLayout being measured as UNSPECIFIED, which it does not support.
     */
    private static final int MIN_CONTENT_DIMEN = 5;

    static final int STATE_NONE = -1;
    static final int STATE_SMALL = 0;
    static final int STATE_ANIMATING = 1;
    static final int STATE_OPEN = 2;

    /**
     * Time for which the scroll hint is shown before automatically changing page.
     */
    public static final int SCROLL_HINT_DURATION = DragController.SCROLL_DELAY;

    /**
     * Fraction of icon width which behave as scroll region.
     */
    private static final float ICON_OVERSCROLL_WIDTH_FACTOR = 0.45f;

    private static final int FOLDER_NAME_ANIMATION_DURATION = 633;

    private static final int REORDER_DELAY = 250;
    private static final int ON_EXIT_CLOSE_DELAY = 400;
    private static final Rect sTempRect = new Rect();

    private static String sDefaultFolderName = null;
    private static String sHintText;

    private final Alarm mReorderAlarm = new Alarm();
    private final Alarm mOnExitAlarm = new Alarm();
    private final Alarm mOnScrollHintAlarm = new Alarm();
    @Thunk final Alarm mScrollPauseAlarm = new Alarm();

    @Thunk final ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();

    private final int mExpandDuration;
    private final int mMaterialExpandDuration;
    private final int mMaterialExpandStagger;

    private final InputMethodManager mInputMethodManager;

    protected final Launcher mLauncher;
    protected DragController mDragController;
    protected FolderInfo mInfo;

    @Thunk FolderIcon mFolderIcon;

    @Thunk FolderPagedView mContent;
    @Thunk View mContentWrapper;

    // add for folder style by liuqiushou 20170620 @{
    //zhaosuzhou add start {
    @Thunk View mEditClearBtn;
    private int mScreenMaxWidth;
    private int mScreenMaxHeight;
    private String mOldFolderName;
    // } end
    //@}

    @Thunk ExtendedEditText mFolderName;

    //update  by huanghaihao in 2017-7-26 for updating forder xml start
    private View mHeader;
    private int mHeaderHeight;
    //update  by huanghaihao in 2017-7-26 for updating forder xml end

    // Cell ranks used for drag and drop
    @Thunk int mTargetRank, mPrevTargetRank, mEmptyCellRank;

    @Thunk int mState = STATE_NONE;
    private boolean mRearrangeOnClose = false;
    boolean mItemsInvalidated = false;
    private ShortcutInfo mCurrentDragInfo;
    private View mCurrentDragView;
    //update by huanghaihao in 2017-7-24 for adding more app in folder  @{
    @Thunk boolean mIsExternalDrag;
    //@}
    boolean mSuppressOnAdd = false;
    private boolean mDragInProgress = false;
    private boolean mDeleteFolderOnDropCompleted = false;
    private boolean mSuppressFolderDeletion = false;
    private boolean mItemAddedBackToSelfViaIcon = false;
    @Thunk float mFolderIconPivotX;
    @Thunk float mFolderIconPivotY;
    private boolean mIsEditingName = false;

    private boolean mDestroyed;

    @Thunk Runnable mDeferredAction;
    private boolean mDeferDropAfterUninstall;
    private boolean mUninstallSuccessful;
    //add by liuning for gome dropTargetButton style on 2017/7/18 start
    private boolean mIsRemoveSystemApp;
    private boolean mIsDropIntoMoveTarget;
    //add by liuning for gome dropTargetButton style on 2017/7/18 end

    // Folder scrolling
    private int mScrollAreaOffset;

    @Thunk int mScrollHintDir = DragController.SCROLL_NONE;
    @Thunk int mCurrentScrollDir = DragController.SCROLL_NONE;
    //add by huanghaihao in 2017-07-14 for adding more app in folder @{
    private AppSearchWindow mPopWindow;
    //@}
    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attributes set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);
        setAlwaysDrawnWithCacheEnabled(false);
        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

        Resources res = getResources();
        mExpandDuration = res.getInteger(R.integer.config_folderExpandDuration);
        mMaterialExpandDuration = res.getInteger(R.integer.config_materialFolderExpandDuration);
        mMaterialExpandStagger = res.getInteger(R.integer.config_materialFolderExpandStagger);

        if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }
        if (sHintText == null) {
            sHintText = res.getString(R.string.folder_hint_text);
        }
        mLauncher = (Launcher) context;
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behavior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        // add for folder style by liuqiushou 20170620 @{
        //zhaosuzhou add start {
        DisplayMetrics dm = Utilities.getDisplayMetrics(getContext());
        mScreenMaxWidth = dm.widthPixels;
        mScreenMaxHeight = dm.heightPixels;

        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        mContentWrapper = findViewById(R.id.folder_content_wrapper);
        mContent = (FolderPagedView) findViewById(R.id.folder_content);
        mContent.setFolder(this);

        mHeader = findViewById(R.id.folder_header);
        // We find out how tall footer wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        int measureSpec = MeasureSpec.UNSPECIFIED;
        mHeader.measure(measureSpec, measureSpec);
        mHeaderHeight = mHeader.getMeasuredHeight();
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        mEditClearBtn = findViewById(R.id.edit_clear);
        mEditClearBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                DLog.e(TAG, "Folder --> onClickEditClearBtnListener 33");
                mFolderName.getText().clear();
            }
        });
        // } end
        //@}

        mFolderName = (ExtendedEditText) findViewById(R.id.folder_name);
        mFolderName.setOnBackKeyListener(new ExtendedEditText.OnBackKeyListener() {
            @Override
            public boolean onBackKey() {
                // Close the activity on back key press
                doneEditingFolderName(true);
                return false;
            }
        });
        mFolderName.setOnFocusChangeListener(this);

        if (!Utilities.ATLEAST_MARSHMALLOW) {
            // We disable action mode in older OSes where floating selection menu is not yet
            // available.
            mFolderName.setCustomSelectionActionModeCallback(new ActionMode.Callback() {
                public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
                    return false;
                }

                public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                    return false;
                }

                public void onDestroyActionMode(ActionMode mode) {
                }

                public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                    return false;
                }
            });
        }
        mFolderName.setOnEditorActionListener(this);
        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);

        //add for hiding background and clear button of folder name
        //by liuqiushou 20170629 @{
        setVisibility(false);
        //@}
    }

    public void onClick(View v) {
        Object tag = v.getTag();
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onClick: v = " + v + ", tag = " + tag);
        }
        if (tag instanceof ShortcutInfo) {
            mLauncher.onClick(v);
        }
        //add by huanghaihao in 2017-07-14 for adding more app in folder @{
        if (null != tag) {
            if (LauncherLog.DEBUG) {
                LauncherLog.d(TAG, "return ,becauce tag isn't null when click in folder");
            }
            return;
        }
        if (null == mPopWindow) {
            View contentView = mLauncher.getLayoutInflater().inflate(R.layout.folder_all_apps_pop_window, null);
            mPopWindow = new AppSearchWindow(contentView, this);
            mPopWindow.setFocusable(true);
            mPopWindow.setClippingEnabled(false);
            mPopWindow.show(v);
        } else {
            mPopWindow.show(v);
        }
        /**
         * Added by gaoquan 2017.7.25
         */
        //-------------------------------start--------------///
        mLauncher.isShowAppSearchWindow = true;
        //-------------------------------end--------------///
        //@}
    }

    public boolean onLongClick(View v) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onLongClick: v = " + v + ", tag = " + v.getTag());
        }
        // Return if global dragging is not enabled
        if (!mLauncher.isDraggingEnabled()) return true;
        return beginDrag(v, false);
    }

    private boolean beginDrag(View v, boolean accessible) {
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }

            mLauncher.getWorkspace().beginDragShared(v, new Point(), this, accessible);

            mCurrentDragInfo = item;
            mEmptyCellRank = item.rank;
            mCurrentDragView = v;
            //add by huanghaihao in 2017-07-14 for adding more app in folder @{
            mContent.removePlusIcon();
            // }@
            mContent.removeItem(mCurrentDragView);
            mInfo.remove(mCurrentDragInfo);
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
        }
        return true;
    }

    @Override
    public void startDrag(CellInfo cellInfo, boolean accessible) {
        beginDrag(cellInfo.cell, accessible);
    }

    @Override
    public void enableAccessibleDrag(boolean enable) {
        mLauncher.getSearchDropTargetBar().enableAccessibleDrag(enable);
        for (int i = 0; i < mContent.getChildCount(); i++) {
            mContent.getPageAt(i).enableAccessibleDrag(enable, CellLayout.FOLDER_ACCESSIBILITY_DRAG);
        }
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        mHeader.setImportantForAccessibility(enable ? IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS :
                IMPORTANT_FOR_ACCESSIBILITY_AUTO);
        //update  by huanghaihao in 2017-7-26 for updating forder xml end
        mLauncher.getWorkspace().setAddNewPageOnDrag(!enable);
    }

    public boolean isEditingName() {
        return mIsEditingName;
    }

    public void startEditingFolderName() {
        //mod for showing background and clear button of folder name
        // by liuqiushou 20170629 @{
        setVisibility(true);
        //mFolderName.setHint("");
        //@}
        mIsEditingName = true;
    }

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }

    public void doneEditingFolderName(boolean commit) {
        //mod for hiding background and clear button of
        // folder name by liuqiushou 20170629 @{
        setVisibility(false);
        //mFolderName.setHint(sHintText);
        //@}

        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String newTitle = mFolderName.getText().toString();
        //add to restore old folder name if current name only contains empty charaters by liuqiushou 20170623 @{
        if(TextUtils.isEmpty(mFolderName.getText().toString().trim())){
            newTitle = mOldFolderName;
            mFolderName.setText(newTitle);
        }
        //@}
        mInfo.setTitle(newTitle);
        //added by liuning for GMOS-7966 on 2017/9/19 start
        mOldFolderName = newTitle;
        //added by liuning for GMOS-7966 on 2017/9/19 end
        LauncherModel.updateItemInDatabase(mLauncher, mInfo);

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }

        // This ensures that focus is gained every time the field is clicked, which selects all
        // the text and brings up the soft keyboard if necessary.
        mFolderName.clearFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            dismissEditingName();
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        //mod for clicking clear button by liuqiushou 20170629 @{
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        return mHeader;//mFolderName;
        //update  by huanghaihao in 2017-7-26 for updating forder xml end
        //@}
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @SuppressLint("ClickableViewAccessibility")
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    public void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    public FolderInfo getInfo() {
        return mInfo;
    }

    public void bind(FolderInfo info,BubbleTextViewCreatedListener listener) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;
        Collections.sort(children, ITEM_POS_COMPARATOR);

        ArrayList<ShortcutInfo> overflow = mContent.bindItems(children,listener);

        // If our folder has too many items we prune them from the list. This is an issue
        // when upgrading from the old Folders implementation which could contain an unlimited
        // number of items.
        for (ShortcutInfo item: overflow) {
            mInfo.remove(item);
            LauncherModel.deleteItemFromDatabase(mLauncher, item);
        }

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            //update  by huanghaihao in 2017-7-26 for updating forder xml start
            lp.ignoreInsets = true;
            //update  by huanghaihao in 2017-7-26 for updating forder xml end
            setLayoutParams(lp);
        }
        centerAboutIcon();

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        if (!sDefaultFolderName.contentEquals(mInfo.title)) {
            mFolderName.setText(mInfo.title);
        } else {
            // mod for folder style by liuqiushou 20170620 @{
            //mFolderName.setText("");
            mFolderName.setText(R.string.deafault_folder_name);
            //@}
        }
        //add to save folder name by liuqiushou 20170623 @{
        mOldFolderName = mFolderName.getText().toString();
        //@}
        // In case any children didn't come across during loading, clean up the folder accordingly
        mFolderIcon.post(new Runnable() {
            public void run() {
                //update by huanghaihao in 2017-7-11 for adding more app in folder start
                if (getItemCountWithoutPlus() <= 1 && mInfo.container != LauncherSettings.Favorites.CONTAINER_MOVE) {
                    //update by huanghaihao in 2017-7-11 for adding more app in folder end
                    replaceFolderWithFinalItem();
                }
            }
        });
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param launcher The main activity.
     *
     * @return A new UserFolder.
     */
    @SuppressLint("InflateParams")
    public static Folder fromXml(Launcher launcher) {
        //mod for Folder style by liuqiushou 20170620 @{
        /*return (Folder) launcher.getLayoutInflater().inflate(
                FeatureFlags.LAUNCHER3_ICON_NORMALIZATION
                        ? R.layout.user_folder_icon_normalized : R.layout.user_folder, null);*/
        return (Folder) launcher.getLayoutInflater().inflate(FeatureFlags.LAUNCHER3_ICON_NORMALIZATION
                        ? R.layout.user_folder_icon_normalized : R.layout.user_folder_gome, null);
        //@}
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        setScaleX(0.8f);
        setScaleY(0.8f);
        setAlpha(0f);
        mState = STATE_SMALL;
    }

    private void prepareReveal() {
        setScaleX(1f);
        setScaleY(1f);
        setAlpha(1f);
        mState = STATE_SMALL;
    }

    public void animateOpen() {
        if (!(getParent() instanceof DragLayer)) return;

        mContent.completePendingPageChanges();
        if (!mDragInProgress) {
            // Open on the first page.
            mContent.snapToPageImmediately(0);
        }

        // This is set to true in close(), but isn't reset to false until onDropCompleted(). This
        // leads to an consistent state if you drag out of the folder and drag back in without
        // dropping. One resulting issue is that replaceFolderWithFinalItem() can be called twice.
        mDeleteFolderOnDropCompleted = false;

        Animator openFolderAnim = null;
        final Runnable onCompleteRunnable;
        if (!Utilities.ATLEAST_LOLLIPOP) {
            positionAndSizeAsIcon();
            centerAboutIcon();

            PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
            PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
            PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
            final ObjectAnimator oa =
                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
            oa.setDuration(mExpandDuration);
            openFolderAnim = oa;

            setLayerType(LAYER_TYPE_HARDWARE, null);
            onCompleteRunnable = new Runnable() {
                @Override
                public void run() {
                    setLayerType(LAYER_TYPE_NONE, null);
                }
            };
        } else {
            prepareReveal();
            centerAboutIcon();

            AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
            int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
            int height = getFolderHeight();
            //update  by huanghaihao in 2017-7-26 for updating forder xml start
//            float transX = - 0.075f * (width / 2 - getPivotX());
//            float transY = - 0.075f * (height / 2 - getPivotY());
            //del for folder style by liuqiusou 20170622 @{
            //setTranslationX(transX);
            //setTranslationY(transY);
              //@}
//            PropertyValuesHolder tx = PropertyValuesHolder.ofFloat("translationX", transX, 0);
//            PropertyValuesHolder ty = PropertyValuesHolder.ofFloat("translationY", transY, 0);

//            Animator drift = ObjectAnimator.ofPropertyValuesHolder(this, tx, ty);
//            drift.setDuration(mMaterialExpandDuration);
//            drift.setStartDelay(mMaterialExpandStagger);
//            drift.setInterpolator(new LogDecelerateInterpolator(100, 0));
            //update  by huanghaihao in 2017-7-26 for updating forder xml start
            int rx = (int) Math.max(Math.max(width - getPivotX(), 0), getPivotX());
            int ry = (int) Math.max(Math.max(height - getPivotY(), 0), getPivotY());
            float radius = (float) Math.hypot(rx, ry);
            /**M: [Changes]If the hardware is accelerated, then allow to use Reveal animator.@{**/
            boolean isHardwareAccelerated = this.isHardwareAccelerated();
            Animator reveal = null;
//            if (isHardwareAccelerated) {
//                reveal = UiThreadCircularReveal.createCircularReveal(this, (int) getPivotX(),
//                        (int) getPivotY(), 0, radius);
//                reveal.setDuration(mMaterialExpandDuration);
//                reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));
//            }
            /**@}**/

            mContentWrapper.setAlpha(0f);
            Animator iconsAlpha = ObjectAnimator.ofFloat(mContentWrapper, "alpha", 0f, 1f);
            iconsAlpha.setDuration(mMaterialExpandDuration);
            iconsAlpha.setStartDelay(mMaterialExpandStagger);
            iconsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));
            //update  by huanghaihao in 2017-7-26 for updating forder xml start
            mHeader.setAlpha(0f);
            Animator textAlpha = ObjectAnimator.ofFloat(mHeader, "alpha", 0f, 1f);
            //update  by huanghaihao in 2017-7-26 for updating forder xml end
            // mod for Folder transplant by liuqiushou 20170620 @{
             /*
            textAlpha.setDuration(mMaterialExpandDuration);
            textAlpha.setStartDelay(mMaterialExpandStagger);
            textAlpha.setInterpolator(new AccelerateInterpolator(1.5f));

            anim.play(drift);
             */
            Animator scaleX = ObjectAnimator.ofFloat(this, "scaleX", 0f, 1.0f);
            Animator scaleY = ObjectAnimator.ofFloat(this, "scaleY", 0f, 1.0f);
            //@}

            anim.play(iconsAlpha);
            anim.play(textAlpha);
            /**M: [Changes]If the hardware is accelerated, then allow to use Reveal animator.@{**/
            if (isHardwareAccelerated) {
                anim.play(reveal);
            }
            /**@}**/

            //add for Folder transplant by liuqiushou 20170620 @{
            anim.play(scaleX);
            anim.play(scaleY);

            anim.setInterpolator(new LogDecelerateInterpolator(100, 0));
            anim.setDuration(mMaterialExpandDuration);
             //@}

            openFolderAnim = anim;

            mContentWrapper.setLayerType(LAYER_TYPE_HARDWARE, null);
            //update  by huanghaihao in 2017-7-26 for updating forder xml start
            mHeader.setLayerType(LAYER_TYPE_HARDWARE, null);
            //update  by huanghaihao in 2017-7-26 for updating forder xml end
            onCompleteRunnable = new Runnable() {
                @Override
                public void run() {
                    mContentWrapper.setLayerType(LAYER_TYPE_NONE, null);
                    //update  by huanghaihao in 2017-7-26 for updating forder xml start
                    mHeader.setLayerType(LAYER_TYPE_NONE, null);
                    //update  by huanghaihao in 2017-7-26 for updating forder xml end
                }
            };
        }
        openFolderAnim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        mContent.getAccessibilityDescription());
                mState = STATE_ANIMATING;
                //add by huanghaihao in 2017-07-24 for adding more app in folder @{
                if (isExternalManage()) {
                    mContent.removePlusIcon();
                } else {
                    mContent.createAndAddPlusIcon(mContent.getItemCountWithoutPlus());
                }
                //}@
            }

            @Override
            public void onAnimationEnd(Animator animation) {
                mState = STATE_OPEN;

                onCompleteRunnable.run();
                mContent.setFocusOnFirstChild();
            }
        });

        // add false for Folder transplant by liuqiushou 20170620 @{
        //zhaosuzhou  note
        // Increase the condition, do not perform more than 1 logical pages
        // Footer animation
        if (false && mContent.getPageCount() > 1 && !mInfo.hasOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION)) {
        // @}
            int footerWidth = mContent.getDesiredWidth()
                    - mHeader.getPaddingLeft() - mHeader.getPaddingRight();

            float textWidth =  mFolderName.getPaint().measureText(mFolderName.getText().toString());
            float translation = (footerWidth - textWidth) / 2;
            mFolderName.setTranslationX(mContent.mIsRtl ? -translation : translation);
            mContent.setMarkerScale(0);

            // Do not update the flag if we are in drag mode. The flag will be updated, when we
            // actually drop the icon.
            final boolean updateAnimationFlag = !mDragInProgress;
            openFolderAnim.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    mFolderName.animate().setDuration(FOLDER_NAME_ANIMATION_DURATION)
                        .translationX(0)
                        .setInterpolator(Utilities.ATLEAST_LOLLIPOP ?
                                AnimationUtils.loadInterpolator(mLauncher,
                                        android.R.interpolator.fast_out_slow_in)
                                : new LogDecelerateInterpolator(100, 0));
                    mContent.animateMarkers();

                    if (updateAnimationFlag) {
                        mInfo.setOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION, true, mLauncher);
                    }
                }
            });
        } else {
            mFolderName.setTranslationX(0);
            mContent.setMarkerScale(1);
        }

        openFolderAnim.start();

        // Make sure the folder picks up the last drag move even if the finger doesn't move.
        //modify by chenchao 2017.8.3
//        if (mDragController.isDragging()) {
//            mDragController.forceTouchMove();
//        }
        //modify by chenchao 2017.8.3
        FolderPagedView pages = (FolderPagedView) mContent;
        pages.verifyVisibleHighResIcons(pages.getNextPage());
    }

    public void beginExternalDrag(ShortcutInfo item) {
        mCurrentDragInfo = item;
        //update by huanghaihao in 2017-07-14 for adding more app in folder @{
        mIsExternalDrag = true;
        mDragInProgress = true;

        mEmptyCellRank = mContent.allocateRankForNewItem(item);
        //@}

        // Since this folder opened by another controller, it might not get onDrop or
        // onDropComplete. Perform cleanup once drag-n-drop ends.
        mDragController.addDragListener(this);
    }

    @Override
    public void onDragStart(DragSource source, Object info, int dragAction) {
    }

    @Override
    public void onDragEnd() {
	    //modify by liuning for multi apps move on 2017/7/18 start
        if (mIsExternalDrag && mDragInProgress && !mLauncher.getWorkspace().isInAppManageMode()) {
            completeDragExit();
        }
		//modify by liuning for multi apps move on 2017/7/18 end
        mDragController.removeDragListener(this);
    }

    @Thunk void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    private static final float sFoldScaleX = 0.2f;
    private static final float sFoldScaleY = 0.17f;

    public void animateClosed() {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "animateClosed: parent = " + getParent());
        }
        if (!(getParent() instanceof DragLayer)) return;
        AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
        Animator alpha = ObjectAnimator.ofFloat(this, "alpha", 1.0f, 0f);
        Animator scaleX = ObjectAnimator.ofFloat(this, "scaleX", 1.0f, sFoldScaleX);
        Animator scaleY = ObjectAnimator.ofFloat(this, "scaleY", 1.0f, sFoldScaleY);

        anim.play(alpha);
        anim.play(scaleX);
        anim.play(scaleY);
        anim.setInterpolator(new LinearInterpolator());
//        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
//        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0);
//        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0);


//        final ObjectAnimator oa =
//                LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);

        anim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                setLayerType(LAYER_TYPE_NONE, null);
                close(true);
                /**
                 * Added by gaoquan 2017.9.28i
                 */
                //-------------------------------start--------------///
                mLauncher.mIsFolderAnimate = false;
                //-------------------------------end--------------///
            }

            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        getContext().getString(R.string.folder_closed));
                mState = STATE_ANIMATING;
            }
        });
        anim.setDuration(mMaterialExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        anim.start();
    }

    public void close(boolean wasAnimated) {
        // TODO: Clear all active animations.
        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
        }
        mDragController.removeDropTarget(this);
        clearFocus();
        if (wasAnimated) {
            mFolderIcon.requestFocus();
        }

        if (mRearrangeOnClose) {
            rearrangeChildren();
            mRearrangeOnClose = false;
        }
        //update by huanghaihao in 2017-7-11 for adding more app in folder start
        if (getItemCountWithoutPlus() <= 1) {
            //update by huanghaihao in 2017-7-11 for adding more app in folder end
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
        clearDragInfo();
        if (mPopWindow != null && mPopWindow.isShowing()) {
            mPopWindow.dismiss();
        }
        mState = STATE_SMALL;
    }

    public boolean acceptDrop(DragObject d) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "acceptDrop: DragObject = " + d);
        }

        final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                    itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
                    !isFull());
    }

    public void onDragEnter(DragObject d) {
        mPrevTargetRank = -1;
        mOnExitAlarm.cancelAlarm();
        // Get the area offset such that the folder only closes if half the drag icon width
        // is outside the folder area
        mScrollAreaOffset = d.dragView.getDragRegionWidth() / 2 - d.xOffset;
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            mContent.realTimeReorder(mEmptyCellRank, mTargetRank);
            mEmptyCellRank = mTargetRank;
        }
    };

    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }

    @Override
    public void onDragOver(DragObject d) {
        onDragOver(d, REORDER_DELAY);
    }

    private int getTargetRank(DragObject d, float[] recycle) {
        recycle = d.getVisualCenter(recycle);
        //modify by liuning for realTimeReorder on 2017/6/28 start
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        return mContent.findNearestArea(
                (int) recycle[0] - getPaddingLeft(), (int) recycle[1] - getPaddingTop() - mHeaderHeight);
        //update  by huanghaihao in 2017-7-26 for updating forder xml end
        //modify by liuning for realTimeReorder on 2017/6/28 end
    }

    @Thunk void onDragOver(DragObject d, int reorderDelay) {
        if (mScrollPauseAlarm.alarmPending()) {
            return;
        }
        final float[] r = new float[2];
        mTargetRank = getTargetRank(d, r);

        if (mTargetRank != mPrevTargetRank) {
            mReorderAlarm.cancelAlarm();
            mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
            mReorderAlarm.setAlarm(REORDER_DELAY);
            mPrevTargetRank = mTargetRank;

            if (d.stateAnnouncer != null) {
                d.stateAnnouncer.announce(getContext().getString(R.string.move_to_position,
                        mTargetRank + 1));
            }
        }

        float x = r[0];
        int currentPage = mContent.getNextPage();

        float cellOverlap = mContent.getCurrentCellLayout().getCellWidth()
                * ICON_OVERSCROLL_WIDTH_FACTOR;
        boolean isOutsideLeftEdge = x < cellOverlap;
        boolean isOutsideRightEdge = x > (getWidth() - cellOverlap);

        if (currentPage > 0 && (mContent.mIsRtl ? isOutsideRightEdge : isOutsideLeftEdge)) {
            showScrollHint(DragController.SCROLL_LEFT, d);
        } else if (currentPage < (mContent.getPageCount() - 1)
                && (mContent.mIsRtl ? isOutsideLeftEdge : isOutsideRightEdge)) {
            showScrollHint(DragController.SCROLL_RIGHT, d);
        } else {
            mOnScrollHintAlarm.cancelAlarm();
            if (mScrollHintDir != DragController.SCROLL_NONE) {
                mContent.clearScrollHint();
                mScrollHintDir = DragController.SCROLL_NONE;
            }
        }
    }

    private void showScrollHint(int direction, DragObject d) {
        // Show scroll hint on the right
        if (mScrollHintDir != direction) {
            mContent.showScrollHint(direction);
            mScrollHintDir = direction;
        }

        // Set alarm for when the hint is complete
        if (!mOnScrollHintAlarm.alarmPending() || mCurrentScrollDir != direction) {
            mCurrentScrollDir = direction;
            mOnScrollHintAlarm.cancelAlarm();
            mOnScrollHintAlarm.setOnAlarmListener(new OnScrollHintListener(d));
            mOnScrollHintAlarm.setAlarm(SCROLL_HINT_DURATION);

            mReorderAlarm.cancelAlarm();
            mTargetRank = mEmptyCellRank;
        }
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

    public void completeDragExit() {
        if (mInfo.opened) {
            mLauncher.closeFolder();
            mRearrangeOnClose = true;
        } else if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            rearrangeChildren();
            clearDragInfo();
        }
    }

    private void clearDragInfo() {
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mIsExternalDrag = false;
    }

    public void onDragExit(DragObject d) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDragExit: DragObject = " + d);
        }

        // We only close the folder if this is a true drag exit, ie. not because
        // a drop has occurred above the folder.
        if (!d.dragComplete) {
		    //modify by liuning for multi apps move on 2017/7/18 start
            if (!(mLauncher.getWorkspace().isInAppManageMode() && d.dragSource instanceof MoveViewsRestContainer)) {
                mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
                mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
            }
			//modify by liuning for multi apps move on 2017/7/18 end
        }

        mReorderAlarm.cancelAlarm();

        mOnScrollHintAlarm.cancelAlarm();
        mScrollPauseAlarm.cancelAlarm();
        if (mScrollHintDir != DragController.SCROLL_NONE) {
            mContent.clearScrollHint();
            mScrollHintDir = DragController.SCROLL_NONE;
        }
    }

    /**
     * When performing an accessibility drop, onDrop is sent immediately after onDragEnter. So we
     * need to complete all transient states based on timers.
     */
    @Override
    public void prepareAccessibilityDrop() {
        if (mReorderAlarm.alarmPending()) {
            mReorderAlarm.cancelAlarm();
            mReorderAlarmListener.onAlarm(mReorderAlarm);
        }
    }

    public void onDropCompleted(final View target, final DragObject d,
            final boolean isFlingToDelete, final boolean success) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDropCompleted: View = " + target + ", DragObject = " + d
                    + ", isFlingToDelete = " + isFlingToDelete + ", success = " + success);
        }

        if (mDeferDropAfterUninstall) {
            Log.d(TAG, "Deferred handling drop because waiting for uninstall.");
            mDeferredAction = new Runnable() {
                    public void run() {
                        onDropCompleted(target, d, isFlingToDelete, success);
                        mDeferredAction = null;
                    }
                };
            return;
        }

        boolean beingCalledAfterUninstall = mDeferredAction != null;
        boolean successfulDrop =
                success && (!beingCalledAfterUninstall || mUninstallSuccessful);

        if (successfulDrop) {
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon && target != this) {
                replaceFolderWithFinalItem();
            }
        } else {
            // The drag failed, we need to return the item to the folder
            ShortcutInfo info = (ShortcutInfo) d.dragInfo;
            View icon = (mCurrentDragView != null && mCurrentDragView.getTag() == info)
                    ? mCurrentDragView : mContent.createNewView(info);
            ArrayList<View> views = getItemsInReadingOrder();
            views.add(info.rank, icon);
            mContent.arrangeChildren(views, views.size());
            mItemsInvalidated = true;

            mSuppressOnAdd = true;
            mFolderIcon.onDrop(d);
            mSuppressOnAdd = false;
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                if (!successfulDrop) {
                    mSuppressFolderDeletion = true;
                }
                mScrollPauseAlarm.cancelAlarm();
                completeDragExit();
            }
        }

        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;

        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabaseBatch();

        // Use the item count to check for multi-page as the folder UI may not have
        // been refreshed yet.
        //update by huanghaihao in 2017-7-11 for adding more app in folder start
        if (getItemCountWithoutPlus() <= mContent.itemsPerPage()) {
            //update by huanghaihao in 2017-7-11 for adding more app in folder end
            // Show the animation, next time something is added to the folder.
            mInfo.setOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION, false, mLauncher);
        }
		//add by liuning for multi apps move on 2017/7/18 start
        if (mLauncher.getWorkspace().getState() != Workspace.State.APP_MANAGE) {
            if (d.cancelled) {
                mLauncher.getWorkspace().showPageScaleAinimation(true, false);
            } else if (mIsRemoveSystemApp || !success) {
                mLauncher.getWorkspace().showPageScaleAinimation(true, true);
            }
        }
        mIsRemoveSystemApp = false;
        mIsDropIntoMoveTarget = false;
		//add by liuning for multi apps move on 2017/7/18 end

    }

    @Override
    public void deferCompleteDropAfterUninstallActivity() {
        mDeferDropAfterUninstall = true;
    }

    @Override
    public void onUninstallActivityReturned(boolean success) {
        mDeferDropAfterUninstall = false;
        mUninstallSuccessful = success;
        if (mDeferredAction != null) {
            mDeferredAction.run();
        }
    }

    //add by liuning for multi apps move on 2017/7/18 start
    @Override
    public void onRemoveSystemAppOrFolder() {
        mIsRemoveSystemApp = true;
    }

    @Override
    public void onDropToMoveTarget() {
        mIsDropIntoMoveTarget = true;
    }
    //add by liuning for multi apps move on 2017/7/18 end

    @Override
    public float getIntrinsicIconScaleFactor() {
        return 1f;
    }

    @Override
    public boolean supportsFlingToDelete() {
        return true;
    }

    @Override
    public boolean supportsAppInfoDropTarget() {
        return false;
    }

    @Override
    public boolean supportsDeleteDropTarget() {
        return true;
    }

    @Override
    public void onFlingToDelete(DragObject d, PointF vec) {
        // Do nothing
    }

    @Override
    public void onFlingToDeleteCompleted() {
        // Do nothing
    }

    private void updateItemLocationsInDatabaseBatch() {
        ArrayList<View> list = getItemsInReadingOrder();
        ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            info.rank = i;
            items.add(info);
        }

        LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
    }

    public void addItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0,
                    info.cellX, info.cellY);
        }
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return true;
    }

    public boolean isFull() {
        return mContent.isFull();
    }

    private void centerAboutIcon() {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
        int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
        int height = getFolderHeight();

        float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, sTempRect);
        int folderIconHeight = sTempRect.height();
        DeviceProfile grid = mLauncher.getDeviceProfile();

        //this is foldIcon center
        int centerX = (int) (sTempRect.left + sTempRect.width() * scale / 2);
        int centerY = (int) (sTempRect.top + sTempRect.height() * scale / 2);

        int centeredLeft = centerX - width / 2;
        int centeredTop = centerY - height / 2;

        // We need to bound the folder to the currently visible workspace area
        mLauncher.getWorkspace().getPageAreaRelativeToDragLayer(sTempRect);
        int left = Math.min(Math.max(sTempRect.left, centeredLeft),
                sTempRect.left + sTempRect.width() - width);
        int top = Math.min(Math.max(sTempRect.top, centeredTop),
                sTempRect.top + sTempRect.height() - height);
        if (grid.isPhone && (grid.availableWidthPx - width) < grid.iconSizePx) {
            // Center the folder if it is full (on phones only)
            left = (grid.availableWidthPx - width) / 2;
        } else if (width >= sTempRect.width()) {
            // If the folder doesn't fit within the bounds, center it about the desired bounds
            left = sTempRect.left + (sTempRect.width() - width) / 2;
        }
        if (height >= sTempRect.height()) {
            top = sTempRect.top + (sTempRect.height() - height) / 2;
        }

        Log.d(TAG, "centerAboutIcon now, after sTempRect = " + sTempRect
               + "mFolderIcon = " + mFolderIcon);
        int folderPivotX = width / 2 + (centeredLeft - left);
        int folderPivotY = height / 2 + (centeredTop - top);
        // mod for folder style by liuqiushou 20170622 @{
        //zhaosuzhou remove Code execution in the following start {
        //setPivotX(folderPivotX);
        //setPivotY(folderPivotY);
        // } end
        //@}

        mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() *
                (1.0f * folderPivotX / width));
        mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() *
                (1.0f * folderPivotY / height));

        lp.width = width;
        lp.height = height;

        // add to Set the start position of the zoom animation when you open the folder,
        // add to Set the final location of the zoom animation when you close the folder
        // mod x, y postion for folder center display by liuqiushou 20170622 @{
        lp.gravity = Gravity.CENTER_HORIZONTAL;
        float screenCenterX = 1.0f * (mScreenMaxWidth - width) / 2;
        float screenCenterY = 1.0f * getResources().getDimensionPixelSize(R.dimen.folder_y_value);
//        setPivotX(centerX - screenCenterX);
//        setPivotY(centerY - screenCenterY);
        float pivotX = 0;
        float pivotY = 0;

        pivotX = centerX - screenCenterX - grid.iconSizePx / 2;
        pivotY = centerY - screenCenterY - mFolderIcon.getMeasuredHeight() / 2;

        setPivotX(pivotX / (1-sFoldScaleX));
        setPivotY(pivotY / (1-sFoldScaleY));

        lp.x = (int) screenCenterX;//left;
        lp.y = (int) screenCenterY;//(int)screenCenterY;//top;
        //add  by huanghaihao in 2017-7-26 for updating forder xml start
        lp.topMargin = lp.y;
        //add  by huanghaihao in 2017-7-26 for updating forder xml end
        //@}
    }

    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    private int getContentAreaHeight() {
        DeviceProfile grid = mLauncher.getDeviceProfile();
        Rect workspacePadding = grid.getWorkspacePadding(mContent.mIsRtl);
        //mod for folder style by liuqiushou 20170620 @{
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        int maxContentAreaHeight = grid.availableHeightPx -
                workspacePadding.top - workspacePadding.bottom - mHeaderHeight;
        //update  by huanghaihao in 2017-7-26 for updating forder xml end
        //@}
        int height = Math.min(maxContentAreaHeight,
                mContent.getDesiredHeight());
        return Math.max(height, MIN_CONTENT_DIMEN);
    }

    private int getContentAreaWidth() {
        return Math.max(mContent.getDesiredWidth(), MIN_CONTENT_DIMEN);
    }

    private int getFolderHeight() {
        return getFolderHeight(getContentAreaHeight());
    }

    private int getFolderHeight(int contentAreaHeight) {
        // mod for adding mFooterHeightName by liuqiushou 20170620 @{
        //return getPaddingTop() + getPaddingBottom() + contentAreaHeight + mFooterHeight;
        return getPaddingTop() + getPaddingBottom() + contentAreaHeight + mHeaderHeight;
        //@}
    }

    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int contentWidth = getContentAreaWidth();
        int contentHeight = getContentAreaHeight();

        int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(contentWidth, MeasureSpec.EXACTLY);
        int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(contentHeight, MeasureSpec.EXACTLY);

        mContent.setFixedSize(contentWidth, contentHeight);
        mContentWrapper.measure(contentAreaWidthSpec, contentAreaHeightSpec);

        /*  del for folder style by liuqiushou 20170620 @{
        if (mContent.getChildCount() > 0) {
            int cellIconGap = (mContent.getPageAt(0).getCellWidth()
                    - mLauncher.getDeviceProfile().iconSizePx) / 2;
            mFooter.setPadding(mContent.getPaddingLeft() + cellIconGap,
                    mFooter.getPaddingTop(),
                    mContent.getPaddingRight() + cellIconGap,
                    mFooter.getPaddingBottom());
        }
        @}
        */
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        mHeader.measure(contentAreaWidthSpec,
                MeasureSpec.makeMeasureSpec(mHeaderHeight, MeasureSpec.EXACTLY));
        //update  by huanghaihao in 2017-7-26 for updating forder xml end
        int folderWidth = getPaddingLeft() + getPaddingRight() + contentWidth;
        int folderHeight = getFolderHeight(contentHeight);
        setMeasuredDimension(folderWidth, folderHeight);
    }

    /**
     * Rearranges the children based on their rank.
     */
    public void rearrangeChildren() {
        rearrangeChildren(-1);
    }

    /**
     * Rearranges the children based on their rank.
     * @param itemCount if greater than the total children count, empty spaces are left at the end,
     * otherwise it is ignored.
     */
    public void rearrangeChildren(int itemCount) {
        ArrayList<View> views = getItemsInReadingOrder();
        mContent.arrangeChildren(views, Math.max(itemCount, views.size()));
        mItemsInvalidated = true;
    }

    // TODO remove this once GSA code fix is submitted
    public ViewGroup getContent() {
        return (ViewGroup) mContent;
    }

    public int getItemCount() {
        return mContent.getItemCount();
    }

    /**
     * app
     * add by huanghaihao in 2017-7-14 for adding more app in folder
     *
     * @return
     */
    public int getItemCountWithoutPlus() {
        return mContent.getItemCountWithoutPlus();
    }

    @Thunk void replaceFolderWithFinalItem() {
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                int itemCount = mInfo.contents.size();
                if (itemCount <= 1) {
                    View newIcon = null;

                    if (itemCount == 1) {
                        // Move the item from the folder to the workspace, in the position of the
                        // folder
                        CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container,
                                mInfo.screenId);
                        ShortcutInfo finalItem = mInfo.contents.remove(0);
                        newIcon = mLauncher.createShortcut(cellLayout, finalItem);
                        LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                                mInfo.screenId, mInfo.cellX, mInfo.cellY);
                    }

                    // Remove the folder
                    mLauncher.removeItem(mFolderIcon, mInfo, true /* deleteFromDb */);
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }

                    if (newIcon != null) {
                        // We add the child after removing the folder to prevent both from existing
                        // at the same time in the CellLayout.  We need to add the new item with
                        // addInScreenFromBind() to ensure that hotseat items are placed correctly.
                        mLauncher.getWorkspace().addInScreenFromBind(newIcon, mInfo.container,
                                mInfo.screenId, mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);

                        // Focus the newly created child
                        newIcon.requestFocus();
                    }
                }
            }
        };
        View finalChild = mContent.getLastItem();
        if (finalChild != null) {
            mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
        } else {
            onCompleteRunnable.run();
        }
        mDestroyed = true;
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the first and last item in the folder for the purposes
    // of keyboard focus
    public void updateTextViewFocus() {
        final View firstChild = mContent.getFirstItem();
        final View lastChild = mContent.getLastItem();
        if (firstChild != null && lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
            // Hitting TAB from the folder name wraps around to the first item on the current
            // folder page, and hitting SHIFT+TAB from that item wraps back to the folder name.
            mFolderName.setNextFocusForwardId(firstChild.getId());
            // When clicking off the folder when editing the name, this Folder gains focus. When
            // pressing an arrow key from that state, give the focus to the first item.
            this.setNextFocusDownId(firstChild.getId());
            this.setNextFocusRightId(firstChild.getId());
            this.setNextFocusLeftId(firstChild.getId());
            this.setNextFocusUpId(firstChild.getId());
            // When pressing shift+tab in the above state, give the focus to the last item.
            setOnKeyListener(new OnKeyListener() {
                @Override
                public boolean onKey(View v, int keyCode, KeyEvent event) {
                    boolean isShiftPlusTab = keyCode == KeyEvent.KEYCODE_TAB &&
                            event.hasModifiers(KeyEvent.META_SHIFT_ON);
                    if (isShiftPlusTab && Folder.this.isFocused()) {
                        return lastChild.requestFocus();
                    }
                    return false;
                }
            });
        }
    }

    public void onDrop(DragObject d) {
        Runnable cleanUpRunnable = null;

        // If we are coming from All Apps space, we defer removing the extra empty screen
        // until the folder closes
        if (d.dragSource != mLauncher.getWorkspace() && !(d.dragSource instanceof Folder)) {
            cleanUpRunnable = new Runnable() {
                @Override
                public void run() {
                    mLauncher.exitSpringLoadedDragModeDelayed(true,
                            Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT,
                            null);
                }
            };
        }
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onDrop: DragObject = " + d);
        }

        // If the icon was dropped while the page was being scrolled, we need to compute
        // the target location again such that the icon is placed of the final page.
        if (!mContent.rankOnCurrentPage(mEmptyCellRank)) {
            // Reorder again.
            mTargetRank = getTargetRank(d, null);

            // Rearrange items immediately.
            mReorderAlarmListener.onAlarm(mReorderAlarm);

            mOnScrollHintAlarm.cancelAlarm();
            mScrollPauseAlarm.cancelAlarm();
        }
        mContent.completePendingPageChanges();

        View currentDragView;
        ShortcutInfo si = mCurrentDragInfo;
        if (mIsExternalDrag) {
            currentDragView = mContent.createAndAddViewForRank(si, mEmptyCellRank);
            // Actually move the item in the database if it was an external drag. Call this
            // before creating the view, so that ShortcutInfo is updated appropriately.
            LauncherModel.addOrMoveItemInDatabase(
                    mLauncher, si, mInfo.id, 0, si.cellX, si.cellY);

            // We only need to update the locations if it doesn't get handled in #onDropCompleted.
            if (d.dragSource != this) {
                updateItemLocationsInDatabaseBatch();
            }
            mIsExternalDrag = false;
        } else {
            currentDragView = mCurrentDragView;
            mContent.addViewForRank(currentDragView, si, mEmptyCellRank);
        }

        if (d.dragView.hasDrawn()) {

            // Temporarily reset the scale such that the animation target gets calculated correctly.
            float scaleX = getScaleX();
            float scaleY = getScaleY();
            setScaleX(1.0f);
            setScaleY(1.0f);
            mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, currentDragView,
                    cleanUpRunnable, null);
            setScaleX(scaleX);
            setScaleY(scaleY);
        } else {
            d.deferDragViewCleanupPostAnimation = false;
            currentDragView.setVisibility(VISIBLE);
        }
        mItemsInvalidated = true;
        rearrangeChildren();
        //linhai add  hotseat start 2017/7/18
        CellLayout.CellInfo dragInfo= mLauncher.getWorkspace().getDragInfo();
        CellLayout parentCell;
        // Reparent the view
        if (dragInfo != null)
        {
             parentCell = mLauncher.getWorkspace().getParentCellLayoutForView(dragInfo.cell);
            if (parentCell != null && mLauncher.isHotseatLayout(parentCell)) {
                parentCell.removeView(dragInfo.cell);
            }
        }
        if (mLauncher.getWorkspace().getOpenFolder().getInfo().container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)
        {
            mLauncher.getWorkspace().sortHotSeatView();
            mLauncher.getHotseat().updateCount();
        }
        //linhai end 2017/7/18

        //added by liuning for show workspace normally when drop on 2017/8/25 start
        if (mLauncher.getWorkspace().getState() != Workspace.State.APP_MANAGE) {
            mLauncher.getWorkspace().showPageScaleAinimation(true, false);
        }
        //added by liuning for show workspace normally when drop on 2017/8/25 end

        // Temporarily suppress the listener, as we did all the work already here.
        mSuppressOnAdd = true;
        mInfo.add(si);
        mSuppressOnAdd = false;
        // Clear the drag info, as it is no longer being dragged.
        mCurrentDragInfo = null;
        mDragInProgress = false;

        if (mContent.getPageCount() > 1) {
            // The animation has already been shown while opening the folder.
            mInfo.setOption(FolderInfo.FLAG_MULTI_PAGE_ANIMATION, true, mLauncher);
        }
    }

    // This is used so the item doesn't immediately appear in the folder when added. In one case
    // we need to create the illusion that the item isn't added back to the folder yet, to
    // to correspond to the animation of the icon back into the folder. This is
    public void hideItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        v.setVisibility(INVISIBLE);
    }
    public void showItem(ShortcutInfo info) {
        View v = getViewForInfo(info);
        v.setVisibility(VISIBLE);
    }

    @Override
    public void onAdd(ShortcutInfo item) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onAdd item = " + item);
        }

        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        if (mSuppressOnAdd) return;
        mContent.createAndAddViewForRank(item, mContent.allocateRankForNewItem(item));
        mItemsInvalidated = true;
        LauncherModel.addOrMoveItemInDatabase(
                mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
    }

    @Override
    public void onAddAll(List<ShortcutInfo> items) {
        for (ShortcutInfo item : items) {
            onAdd(item);
        }
    }

    @Override
    public void onRemove(ShortcutInfo item) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "onRemove item = " + item);
        }

        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        View v = getViewForInfo(item);
        mContent.removeItem(v);
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            rearrangeChildren();
        }
        //update by huanghaihao in 2017-7-11 for adding more app in folder start
        if (getItemCountWithoutPlus() <= 1 && mInfo.container!= LauncherSettings.Favorites.CONTAINER_MOVE) {
            //update by huanghaihao in 2017-7-11 for adding more app in folder end
            if (mInfo.opened) {
                mLauncher.closeFolder(this, true);
            } else {
                replaceFolderWithFinalItem();
            }
        }
    }

    @Override
    public void onRemoveAll(List<ShortcutInfo> items) {
        for (ShortcutInfo item : items) {
            onRemove(item);
        }
    }

    private View getViewForInfo(final ShortcutInfo item) {
        return mContent.iterateOverItems(new ItemOperator() {

            @Override
            public boolean evaluate(ItemInfo info, View view, View parent) {
                return info == item;
            }
        });
    }

    public void onItemsChanged() {
        updateTextViewFocus();
    }

    public void onTitleChanged(CharSequence title) {
        // add for setting folder name by liuqiushou 20170705 @{
        if (!TextUtils.isEmpty(title)) {
            mFolderName.setText(title);
        }
        //@}
    }

    public ArrayList<View> getItemsInReadingOrder() {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            mContent.iterateOverItems(new ItemOperator() {

                @Override
                public boolean evaluate(ItemInfo info, View view, View parent) {
                    //add by huanghaihao in 2017-7-11 for adding more app in folder start
                    if (null != info) {
                        mItemsInReadingOrder.add(view);
                    }
                    //add by huanghaihao in 2017-7-11 for adding more app in folder end
                    return false;
                }
            });
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public void getLocationInDragLayer(int[] loc) {
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName) {
            if (hasFocus && !mLauncher.getWorkspace().isInAppManageMode()) {//modify by liuning for the folder name can not be edited on 2017/7/18
                startEditingFolderName();
            } else {
                dismissEditingName();
            }
        }
    }

    /**
     * add by liuning for foldername can't be edited in the appManageMode on 2017/11/30
     */
    public void setFolderNameEditAble() {
        if (mLauncher.getWorkspace().isInAppManageMode()) {
            mFolderName.setFocusableInTouchMode(false);
        } else {
            mFolderName.setFocusableInTouchMode(true);
        }
    }

    @Override
    public void getHitRectRelativeToDragLayer(Rect outRect) {
        getHitRect(outRect);
        outRect.left -= mScrollAreaOffset;
        outRect.right += mScrollAreaOffset;
        //modify by liuning for top region should not contain the footername on 2017/7/18 start
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        outRect.top += mHeader.getHeight();
        //update  by huanghaihao in 2017-7-26 for updating forder xml end
        //modify by liuning for top region should not contain the footername on 2017/7/18 end
    }

    @Override
    public void fillInLaunchSourceData(View v, Bundle sourceData) {
        // Fill in from the folder icon's launch source provider first
        Stats.LaunchSourceUtils.populateSourceDataFromAncestorProvider(mFolderIcon, sourceData);
        sourceData.putString(Stats.SOURCE_EXTRA_SUB_CONTAINER, Stats.SUB_CONTAINER_FOLDER);
        sourceData.putInt(Stats.SOURCE_EXTRA_SUB_CONTAINER_PAGE, mContent.getCurrentPage());
    }

    @Override
    public void addApps(Folder folder, List<? extends ItemInfo> apps) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "removeApps " + apps);
        }
        mInfo.addAll((List<ShortcutInfo>) apps);
    }

    @Override
    public void removeApps(Folder folder, List<? extends ItemInfo> apps) {
        if (LauncherLog.DEBUG) {
            LauncherLog.d(TAG, "removeApps " + apps);
        }
        mInfo.removeAll((List<ShortcutInfo>) apps);
    }

    private class OnScrollHintListener implements OnAlarmListener {

        private final DragObject mDragObject;

        OnScrollHintListener(DragObject object) {
            mDragObject = object;
        }

        /**
         * Scroll hint has been shown long enough. Now scroll to appropriate page.
         */
        @Override
        public void onAlarm(Alarm alarm) {
            if (mCurrentScrollDir == DragController.SCROLL_LEFT) {
                mContent.scrollLeft();
                mScrollHintDir = DragController.SCROLL_NONE;
            } else if (mCurrentScrollDir == DragController.SCROLL_RIGHT) {
                mContent.scrollRight();
                mScrollHintDir = DragController.SCROLL_NONE;
            } else {
                // This should not happen
                return;
            }
            mCurrentScrollDir = DragController.SCROLL_NONE;

            // Pause drag event until the scrolling is finished
            mScrollPauseAlarm.setOnAlarmListener(new OnScrollFinishedListener(mDragObject));
            mScrollPauseAlarm.setAlarm(DragController.RESCROLL_DELAY);
        }
    }

    private class OnScrollFinishedListener implements OnAlarmListener {

        private final DragObject mDragObject;

        OnScrollFinishedListener(DragObject object) {
            mDragObject = object;
        }

        /**
         * Page scroll is complete.
         */
        @Override
        public void onAlarm(Alarm alarm) {
            // Reorder immediately on page change.
            onDragOver(mDragObject, 1);
        }
    }

    // Compares item position based on rank and position giving priority to the rank.
    public static final Comparator<ItemInfo> ITEM_POS_COMPARATOR = new Comparator<ItemInfo>() {

        @Override
        public int compare(ItemInfo lhs, ItemInfo rhs) {
            if (lhs.rank != rhs.rank) {
                return lhs.rank - rhs.rank;
            } else if (lhs.cellY != rhs.cellY) {
                return lhs.cellY - rhs.cellY;
            } else {
                return lhs.cellX - rhs.cellX;
            }
        }
    };

    /**
     * 
     * add by huanghaihao in 2017-7-24 for adding more app in folder start
     *
     * @return
     */
    public boolean isExternalManage() {
        return mLauncher.getWorkspace().isInAppManageMode() || mIsExternalDrag;
    }

    //add for hiding visibling background and clear button
    // of folder name by liuqiushou 20170629 @{
    private void setVisibility(boolean visiabled) {
        //mFolderName.setHintTextColor(visiabled ? Color.parseColor("#aaffffff") : Color.WHITE);
        mEditClearBtn.setVisibility(visiabled ? View.VISIBLE : View.INVISIBLE);
        //update  by huanghaihao in 2017-7-26 for updating forder xml start
        mHeader.setBackground(visiabled ?
                getResources().getDrawable(R.drawable.bg_folder_title_edit_gome) : null);
        //update  by huanghaihao in 2017-7-26 for updating forder xml end
    }
    //@}

    /**
     * Added by gaoquan 2017.6.1
     */
    //------------------unread start-----------------//

    /**
     * M: Update unread number of the content shortcut.
     */
    public void updateContentUnreadNum() {
        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
                getAllShortcutContainersInFolder();
        int childCount = 0;
        View view = null;
        Object tag = null;

        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
            childCount = layout.getChildCount();
            for (int j = 0; j < childCount; j++) {
                view = layout.getChildAt(j);
                tag = view.getTag();
                if (tag instanceof ShortcutInfo) {
                    final ShortcutInfo info = (ShortcutInfo) tag;
                    ((BubbleTextView) view).invalidate();
                }
            }
        }
    }

    /**
     * We should only use this to search for specific children.  Do not use this method to modify
     * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from
     * the hotseat and workspace pages
     */
    private ArrayList<ShortcutAndWidgetContainer> getAllShortcutContainersInFolder() {
        ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
                new ArrayList<ShortcutAndWidgetContainer>();
        int screenCount = mContent.getChildCount();
        for (int screen = 0; screen < screenCount; screen++) {
            childrenLayouts.add(
                    ((CellLayout) (mContent.getChildAt(screen))).getShortcutsAndWidgets());
        }
        return childrenLayouts;
    }

    //------------------unread end-------------------------//

    public FolderIcon getFolderIcon() {
        return mFolderIcon;
    }

    /**
     * Added by gaoquan 2017.7.20
     */
    //-------------------------------start--------------///
    public void updateContentCircleChanged(){
        final ArrayList<ShortcutAndWidgetContainer> childrenLayouts =
                getAllShortcutContainersInFolder();
        int childCount = 0;
        View view = null;
        Object tag = null;

        for (ShortcutAndWidgetContainer layout : childrenLayouts) {
            childCount = layout.getChildCount();
            for (int j = 0; j < childCount; j++) {
                view = layout.getChildAt(j);
                tag = view.getTag();
                if (tag instanceof ShortcutInfo) {
                    final ShortcutInfo info = (ShortcutInfo) tag;
                    ((BubbleTextView) view).requestLayout();
                    ((BubbleTextView) view).invalidate();
                }
            }
        }
    }
    //-------------------------------end--------------///
}
